name: Pipeline CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# VariÃ¡veis de ambiente disponÃ­veis para todos os jobs no workflow
env:
  ECR_REPOSITORY: pipeline-devops
  AWS_REGION: us-east-1

jobs:
  # Job 1: Executa testes e build local
  test-and-build:
    name: Testes e Build
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout do cÃ³digo
        uses: actions/checkout@v4
      
      - name: Instala o Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Instala as dependÃªncias
        run: npm ci

      - name: Executa testes automatizados
        run: npm run test:ci

      - name: AnÃ¡lise de seguranÃ§a de dependÃªncias
        run: npm audit --audit-level moderate

      - name: Faz o build da aplicaÃ§Ã£o
        run: npm run build

      - name: Cache dos artefatos de build
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: build/
          retention-days: 1

      - name: Registrar sucesso dos testes
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          âœ… **Testes automatizados:** Todos os testes passaram com sucesso
          
          EOF

  # Job 2: Deploy (sÃ³ executa se os testes passaram)
  deploy:
    name: Deploy para AWS ECR
    runs-on: ubuntu-latest
    needs: test-and-build  # SÃ³ executa se o job anterior passou
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'  # SÃ³ no push para main
    
    steps:
      - name: Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: Baixa artefatos de build
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: build/

      - name: Configurar credenciais da AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: 'no'

      - name: Login no Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Definir tag da imagem (SHA do commit)
        id: image_tag
        run: echo "tag=$(echo ${GITHUB_SHA} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Build e Push da imagem para o Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image_tag.outputs.tag }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f Dockerfile .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "âœ… Imagem enviada com sucesso para $ECR_REGISTRY/$ECR_REPOSITORY com as tags '$IMAGE_TAG' e 'latest'"

      - name: Registrar sucesso do build Docker
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image_tag.outputs.tag }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ðŸ³ **Build Docker:** Imagem criada com sucesso (tag: ${IMAGE_TAG})
          
          ðŸ“¤ **Push ECR:** Imagem enviada para ${ECR_REGISTRY}/${ECR_REPOSITORY}
          
          EOF

      - name: Scan de seguranÃ§a da imagem Docker
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image_tag.outputs.tag }}
        run: |
          # Aguarda um pouco para o ECR processar a imagem
          sleep 30
          # Executa scan de vulnerabilidades
          aws ecr start-image-scan --repository-name $ECR_REPOSITORY --image-id imageTag=$IMAGE_TAG || true
          echo "ðŸ” Scan de seguranÃ§a iniciado para a imagem"

      - name: Registrar sucesso do scan de seguranÃ§a
        env:
          IMAGE_TAG: ${{ steps.image_tag.outputs.tag }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ðŸ” **Scan de SeguranÃ§a:** AnÃ¡lise de vulnerabilidades iniciada (tag: ${IMAGE_TAG})
          
          EOF

      - name: Atualizar Task Definition e Deploy do ECS Service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image_tag.outputs.tag }}
        run: |
          # Obter a task definition atual
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition pipeline-devops-task \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition')
          
          # Criar nova task definition com a imagem atualizada
          NEW_IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          echo "ðŸ³ Atualizando task definition com nova imagem: ${NEW_IMAGE_URI}"
          
          # Preparar nova task definition
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE_URI "$NEW_IMAGE_URI" '
            .containerDefinitions[0].image = $IMAGE_URI |
            del(.taskDefinitionArn) |
            del(.revision) |
            del(.status) |
            del(.requiresAttributes) |
            del(.placementConstraints) |
            del(.compatibilities) |
            del(.registeredAt) |
            del(.registeredBy)
          ')
          
          # Registrar nova task definition
          NEW_TASK_DEFINITION_ARN=$(echo $NEW_TASK_DEFINITION | aws ecs register-task-definition \
            --region ${{ env.AWS_REGION }} \
            --cli-input-json file:///dev/stdin \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "âœ… Nova task definition registrada: ${NEW_TASK_DEFINITION_ARN}"
          
          # Atualizar o serviÃ§o ECS com a nova task definition
          aws ecs update-service \
            --cluster pipeline-devops \
            --service pipeline-devops-service \
            --task-definition "${NEW_TASK_DEFINITION_ARN}" \
            --region ${{ env.AWS_REGION }}
          
          echo "ðŸ”„ ServiÃ§o ECS atualizado com nova task definition"
          
          # Aguarda o deployment estabilizar
          echo "â³ Aguardando deployment estabilizar..."
          aws ecs wait services-stable \
            --cluster pipeline-devops \
            --services pipeline-devops-service \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Deployment estabilizado com sucesso"

      - name: Registrar sucesso do deploy
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image_tag.outputs.tag }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ðŸ”„ **Deploy ECS:** Task definition atualizada com nova imagem
          
          ðŸ³ **Nova Imagem:** ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}
          
          EOF

      - name: Mensagem de sucesso do deploy
        run: |
          # Obter URL da aplicaÃ§Ã£o
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `pipeline`) && contains(LoadBalancerName, `alb`)].DNSName' \
            --output text --region ${{ env.AWS_REGION }} | head -n1)
          
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            APP_URL="http://$ALB_DNS"
          else
            APP_URL="Deploy concluÃ­do - ALB nÃ£o encontrado"
          fi
          
          # Criar Job Summary com URL da aplicaÃ§Ã£o
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          ðŸ”— **Acessar AplicaÃ§Ã£o:** [$APP_URL]($APP_URL)
          EOF
          
          # Mensagens de sucesso do deploy
          echo "ðŸš€ Deploy realizado com sucesso!"
          echo "ðŸ“± URL da aplicaÃ§Ã£o: $APP_URL"
